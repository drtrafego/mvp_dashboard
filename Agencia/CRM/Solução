# Documentação da Solução Kanban e CRM

Esta documentação detalha a implementação final do quadro Kanban e do sistema de CRM, abordando as correções de estado, drag-and-drop (DnD), e segurança de dados.

## 1. Arquitetura Kanban Canônica (DnD-Kit)

Implementamos uma arquitetura robusta usando `@dnd-kit` para resolver problemas de "Desalinhamento de Estado" onde leads ou colunas revertiam para posições antigas após o arrasto.

### Principais Conceitos:
*   **Single Source of Truth**: O estado local (`columns`, `leads`) é a verdade absoluta durante a interação do usuário.
*   **Optimistic UI**: A interface é atualizada instantaneamente antes da resposta do servidor.
*   **Separação de Responsabilidades**:
    *   `onDragOver`: Gerencia apenas a movimentação visual dos *Leads* entre colunas.
    *   `onDragEnd`: Gerencia a persistência no banco de dados (Server Actions) e reordenação final.
*   **Prevenção de Race Conditions**: Utilizamos uma ref (`ignoreExternalUpdatesRef`) para ignorar atualizações vindas do servidor enquanto o usuário está arrastando itens, evitando "pulos" na interface.
*   **Limpeza de Cache**: `router.refresh()` é chamado após atualizações críticas para garantir que o cache do Next.js (Client Router Cache) esteja sincronizado com o servidor.

## 2. Código Fonte Final

### `src/components/features/kanban/board.tsx` (O Cérebro)

Este componente gerencia todo o estado e a lógica de arrastar.

```tsx
"use client";

import { useMemo, useState, useEffect, useRef } from "react";
import { createPortal } from "react-dom";
import { useRouter } from "next/navigation";
import {
  DndContext,
  DragOverlay,
  useSensor,
  useSensors,
  PointerSensor,
  KeyboardSensor,
  TouchSensor,
  closestCorners,
  DragStartEvent,
  DragOverEvent,
  DragEndEvent,
} from "@dnd-kit/core";
import {
  SortableContext,
  arrayMove,
  horizontalListSortingStrategy,
  sortableKeyboardCoordinates,
} from "@dnd-kit/sortable";

import { Column } from "./column";
import { LeadCard } from "./lead-card";
import { Lead, Column as ColumnType } from "@/server/db/schema";
import { updateLeadStatus, updateColumnOrder, createColumn } from "@/server/actions/leads";
import { Button } from "@/components/ui/button";
import { PlusIcon } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";

const SENSORS_CONFIG = {
  activationConstraint: {
    distance: 5,
  },
};

interface BoardProps {
  columns: ColumnType[];
  initialLeads: Lead[];
  onLeadsChange?: (leads: Lead[]) => void;
}

export function Board({ columns: initialColumns, initialLeads, onLeadsChange }: BoardProps) {
  const router = useRouter();
  const [columns, setColumns] = useState<ColumnType[]>(initialColumns);
  const [leads, setLeads] = useState<Lead[]>(initialLeads);
  
  const [activeColumn, setActiveColumn] = useState<ColumnType | null>(null);
  const [activeLead, setActiveLead] = useState<Lead | null>(null);

  // Add Column State
  const [isCreateColumnOpen, setIsCreateColumnOpen] = useState(false);
  const [newColumnName, setNewColumnName] = useState("");
  
  // Ref to track local updates and prevent race conditions from server revalidation
  const ignoreExternalUpdatesRef = useRef(false);

  useEffect(() => {
      if (ignoreExternalUpdatesRef.current) {
          const timer = setTimeout(() => {
              ignoreExternalUpdatesRef.current = false;
          }, 2000); // Ignore server updates for 2s after a local move
          return () => clearTimeout(timer);
      }
      setColumns(initialColumns);
  }, [initialColumns]);

  useEffect(() => {
      if (ignoreExternalUpdatesRef.current) return;
      setLeads(initialLeads);
  }, [initialLeads]);

  const sensors = useSensors(
    useSensor(PointerSensor, SENSORS_CONFIG),
    useSensor(TouchSensor),
    useSensor(KeyboardSensor, {
        coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const columnsId = useMemo(() => columns.map((col) => col.id), [columns]);

  function onDragStart(event: DragStartEvent) {
    if (event.active.data.current?.type === "Column") {
      setActiveColumn(event.active.data.current.column);
      return;
    }
    if (event.active.data.current?.type === "Lead") {
      setActiveLead(event.active.data.current.lead);
      return;
    }
  }

  function onDragOver(event: DragOverEvent) {
    const { active, over } = event;
    if (!over) return;

    const activeId = active.id;
    const overId = over.id;

    const isActiveALead = active.data.current?.type === "Lead";
    const isOverALead = over.data.current?.type === "Lead";
    const isOverAColumn = over.data.current?.type === "Column";

    if (!isActiveALead) return;

    // Scenario 1: Dragging Lead over Lead
    if (isActiveALead && isOverALead) {
      setLeads((leads) => {
        const activeIndex = leads.findIndex((l) => l.id === activeId);
        const overIndex = leads.findIndex((l) => l.id === overId);
        
        if (leads[activeIndex].columnId !== leads[overIndex].columnId) {
          const newLeads = [...leads];
          newLeads[activeIndex].columnId = leads[overIndex].columnId; 
          return arrayMove(newLeads, activeIndex, overIndex - 1);
        }
        return leads;
      });
    }

    // Scenario 2: Dragging Lead over Column (empty or header)
    if (isActiveALead && isOverAColumn) {
      setLeads((leads) => {
        const activeIndex = leads.findIndex((l) => l.id === activeId);
        const activeLead = leads[activeIndex];
        
        if (activeLead.columnId === overId) return leads;

        const newLeads = [...leads];
        newLeads[activeIndex].columnId = overId as string;
        return arrayMove(newLeads, activeIndex, activeIndex);
      });
    }
  }

  const [lastError, setLastError] = useState<string | null>(null);

  function onDragEnd(event: DragEndEvent) {
    setActiveColumn(null);
    setActiveLead(null);
    setLastError(null);

    const { active, over } = event;
    if (!over) return;

    const activeId = active.id;
    const overId = over.id;

    // Moving Columns
    if (active.data.current?.type === "Column") {
      if (activeId !== overId) {
        setColumns((columns) => {
          const oldIndex = columns.findIndex((col) => col.id === activeId);
          const newIndex = columns.findIndex((col) => col.id === overId);
          const newOrder = arrayMove(columns, oldIndex, newIndex);
          
          ignoreExternalUpdatesRef.current = true;
          
          updateColumnOrder(newOrder.map(c => c.id))
            .then((response) => {
                if (response.columns) {
                    setColumns(response.columns);
                    router.refresh();
                }
            })
            .catch(err => {
                setLastError(`Erro ao salvar ordem das colunas: ${err.message}`);
                ignoreExternalUpdatesRef.current = false;
            });

          return newOrder;
        });
      }
      return;
    }

    // Moving Leads
    if (active.data.current?.type === "Lead") {
      setLeads((leads) => {
        const activeIndex = leads.findIndex((l) => l.id === activeId);
        const overIndex = leads.findIndex((l) => l.id === overId);
        
        const newOrderedLeads = arrayMove(leads, activeIndex, overIndex);
        const movedLead = newOrderedLeads[overIndex];
        
        const columnLeads = newOrderedLeads.filter(l => l.columnId === movedLead.columnId);
        const newPosition = columnLeads.findIndex(l => l.id === movedLead.id);
        
        ignoreExternalUpdatesRef.current = true;
        
        if (onLeadsChange) {
            onLeadsChange(newOrderedLeads);
        }
        
        updateLeadStatus(movedLead.id, movedLead.columnId!, newPosition)
             .catch(err => {
                setLastError(`Erro ao salvar status do lead: ${err.message}`);
                ignoreExternalUpdatesRef.current = false;
             });
          
        return newOrderedLeads;
      });
    }
  }
  
  const getLeadsByColumn = (columnId: string) => {
    return leads.filter((lead) => lead.columnId === columnId);
  };

  // ... (handleCreateColumn e JSX de renderização)
}
```

### `src/components/features/kanban/column.tsx` (A Coluna Otimizada)

Mudanças principais:
*   Remoção do `useDroppable` (conflitava com IDs de leads).
*   `min-h-[150px]` para permitir drop em colunas vazias.
*   `{...attributes} {...listeners}` aplicados APENAS no cabeçalho da coluna (impede arrastar a coluna ao tentar selecionar texto ou clicar num lead).

```tsx
"use client";

import { SortableContext, useSortable, verticalListSortingStrategy } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { useMemo, useState } from "react";
import { LeadCard } from "./lead-card";
import { cn } from "@/lib/utils";
import { Column as ColumnType, Lead } from "@/server/db/schema";
// ... imports

interface ColumnProps {
  column: ColumnType;
  leads: Lead[];
}

export function Column({ column, leads }: ColumnProps) {
  const {
    setNodeRef,
    attributes,
    listeners,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: column.id,
    data: { type: "Column", column },
  });

  const style = {
    transition,
    transform: CSS.Translate.toString(transform),
  };

  const leadsIds = useMemo(() => leads.map((l) => l.id), [leads]);

  // ... states de edição

  if (isDragging) {
    return (
      <div
        ref={setNodeRef}
        style={style}
        className="w-[300px] min-w-[300px] h-[500px] bg-slate-100/50 border-2 border-dashed border-slate-300 rounded-xl opacity-50"
      />
    );
  }

  return (
    <div 
        ref={setNodeRef} 
        style={style} 
        className="w-[300px] min-w-[300px] flex flex-col h-full bg-slate-100/80 rounded-xl border border-slate-200/60"
    >
      {/* Header: Drag Handle Aqui */}
      <div
        {...attributes}
        {...listeners}
        className="p-3 pb-2 flex items-center justify-between group cursor-grab active:cursor-grabbing touch-none"
      >
         {/* ... Conteúdo do Header */}
      </div>

      {/* Cards Area: Área de Drop dos Leads */}
      <div className="flex-1 p-2 overflow-hidden">
        <div className="h-full pr-3 overflow-y-auto custom-scrollbar min-h-[150px]">
            <SortableContext items={leadsIds} strategy={verticalListSortingStrategy}>
                <div className="flex flex-col gap-3 pb-4">
                    {leads.map((lead) => (
                        <LeadCard key={lead.id} lead={lead} />
                    ))}
                </div>
            </SortableContext>
        </div>
      </div>
    </div>
  );
}
```

## 3. Segurança e Dados (Single Tenant - Compartilhado)

**MUDANÇA IMPORTANTE**: O sistema foi configurado para **Modo Compartilhado (Single Tenant)**.
Isso significa que a segregação de dados por usuário foi removida para atender ao requisito de que toda a equipe veja a mesma tela.

### Como funciona agora:
1.  **ID Compartilhado**: Todos os usuários, webhooks e operações usam um ID fixo: `bilder_agency_shared`.
2.  **Visibilidade Global**: Qualquer pessoa que fizer login no sistema verá os mesmos leads e colunas.
3.  **Webhooks**: Não é mais necessário enviar o `organizationId` no payload do webhook, pois o sistema força o uso do ID compartilhado.

### Código de Integração (Webhook) Atualizado
Para integrar com Zapier, n8n ou formulários, envie um POST para:
`https://seu-crm.com/api/webhooks/leads`

**Payload JSON (Simplificado):**
```json
{
  "name": "Nome do Cliente",
  "email": "cliente@email.com",
  "whatsapp": "11999999999",
  "company": "Empresa LTDA",
  "notes": "Interesse no plano premium...",
  "campaignSource": "Instagram Ads"
}
```
*Nota: O campo `organizationId` é ignorado e atribuído automaticamente para o ambiente compartilhado.*

### Atenção
Como todos compartilham o mesmo ambiente, **qualquer pessoa que criar uma conta no link do seu CRM terá acesso aos dados**. Certifique-se de controlar quem tem acesso ao link de cadastro ou gerenciar os usuários no painel do Stack Auth.
